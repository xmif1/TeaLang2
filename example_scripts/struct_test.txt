tlstruct Vector{
    let v[3]:float = {0.0};

    int Scale(s:float){
        v[0] = v[0]*s;
        v[1] = v[1]*s;
        v[2] = v[2]*s;

        return 0;
    }

    int Translate(t:float[]){
        v = v + t;
        return 0;
    }
}

Vector Add(v1:Vector, v2:Vector){
    let v3:Vector;
    v3.v = v1.v + v2.v;

    return v3;
}

let v1:Vector;
v1.v[0] = 1.0;
v1.v[1] = 2.0;
v1.v[2] = 3.0;

let v2:Vector;
v2.v[0] = 2.0;
v2.v[1] = 1.2;
v2.v[2] = 0.0;

let v3:Vector = Add(v1, v2);
print v3.v[0]; // 3.0
print v3.v[1]; // 3.2
print v3.v[2]; // 2.0

v3.Translate(1.0, 1.0, 1.0);

let v4:Vector = Add(v1, v3);
print v4.v[0]; // 5.0
print v4.v[1]; // 6.2
print v4.v[2]; // 5.0

tlstruct Matrix{
    let m[3]:Vector;

    Matrix Transpose(){
        let m_t:Matrix = m;

        for(let i:int = 0; i < 3; i = i+1){
            let c:Vector;

            for(let j:int = 0; j < 3; j = j+1){
                let v:Vector = m[j];
                c[j] = v.v[i];
            }

            m_t[i] = c;
        }

        return m_t;
    }
}

Matrix HadamardProduct(m1:Matrix, m2:Matrix){
    let mat:Matrix;

    for(let i:int = 0; i < 3; i = i+1){
        mat[i] = HadamardProduct(m1.m[i], m2.m[i]);
    }

    return mat;
}

let m1[3]:Matrix = {v1, v2, v3};
let hp:Matrix = HadamardProduct(m1, m1.Transpose());
print hp.m[0];